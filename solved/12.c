/*The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

> **1** : 1  
>  **3** : 1,3  
>  **6** : 1,2,3,6  
>  **10** : 1,2,5,10  
>  **15** : 1,3,5,15  
>  **21** : 1,3,7,21  
>  **28** : 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred
divisors?

---

First interesting Problem :D

Using the combinatorial number of the powers of all primfactors of N,
compared to simply divding triangle numbers in a loop made the solution
in .2 secounds.

Using primfactors you only have a divide loop till sqrt(n) instead of n/2 or n/4 divisions
for the simple loop, giving you a speedup for the solution of more then 2000.

*/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <time.h>
#include "primes.h"

//generates a Triangle Number
int triangleNumber(int x){
    return (x*x+x)/2;
}

//gets a number, calculates all Primfactors and returns 
//the number of divisors by calculating the combinations possible 
//by the number and power of the primfactors
//calculates in O(sqrt(n)) instead of O(n) compared with dividing till n/2
int getNumDivisors(int num){
    primFactor *p1 = getPrimfactors(num);
    int numDiv=p1->pow+1;
    //while every primfactor is smaller then the next factor (because its a crcular list)
    while(p1->val<p1->next->val){
        p1=p1->next;
        numDiv*=p1->pow+1;
    }
    freePrimfactors(p1);
    return numDiv;
}

int getNumDivisorsSimple(int num){
    int divNum=2; // two because of 1 and num itself
    if(num==1) return 1;
    for (int i = 2; i < num/2+1; ++i){
        if(num%i==0) divNum++;
    }
    return divNum;
}

int main(int argc, char const *argv[]){
    long int a = atoi(argv[1]);


    //using Primefactors
    int num=1;
    clock_t start = clock();
    while(getNumDivisors(triangleNumber(num))<a){
        num+=1;
    }
    clock_t end = clock();
    float time2 = (float)(end - start)/CLOCKS_PER_SEC;

    printf("%d has %d factors needing %lf secs\n", triangleNumber(num), getNumDivisors(triangleNumber(num)), time2);

    //using naive loop
    //num=1;
    //start = clock();
    //while(getNumDivisorsSimple(triangleNumber(num))<a){
    //    num+=1;
    //}
    //end = clock();
    //float time1 = (float)(end - start)/CLOCKS_PER_SEC;
    //printf("%d has %d factors needing %lf secs\n", triangleNumber(num), getNumDivisorsSimple(triangleNumber(num)), time1);
    //printf("Using primfactors is faster by factor %lf secs\n", time1/time2);
    return 0;
}
    