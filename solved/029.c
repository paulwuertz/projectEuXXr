/*Consider all integer combinations of _a_ _b_ for 2 ≤ _a_ ≤ 5 and 2 ≤ _b_ ≤ 5:

> 22=4, 23=8, 24=16, 25=32  
>  32=9, 33=27, 34=81, 35=243  
>  42=16, 43=64, 44=256, 45=1024  
>  52=25, 53=125, 54=625, 55=3125  
>

If they are then placed in numerical order, with any repeats removed, we get
the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by _a_ _b_ for 2 ≤ _a_ ≤
100 and 2 ≤ _b_ ≤ 100?

---

Use the naive way with calculating the results as mpz numbers and compare the results as strings

*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <gmp.h>


/* qsort mpz number saved as char* comparison function */
int cstring_cmp(const void *a, const void *b) { 
    const char **ia = (const char **)a;
    const char **ib = (const char **)b;

    if(strlen(*ia)>strlen(*ib)) return 1;
    else if(strlen(*ia)<strlen(*ib)) return -1;
    else return strcmp(*ia,*ib);
} 

int main(int argc, char const *argv[]){
    int min=2,max=100;
    //saving all results as the result of mpz function 2 string
    char* solutions[(max-min+1)*(max-min+1)];
    
    mpz_t a;
    mpz_init (a);
    mpz_t b;
    mpz_init (b);
    int pos=0,num=0;
    // calc a**b
    for (long signed int i = min; i <= max; ++i){
        mpz_set_si (a, i); 
        for (long unsigned int j = min; j <= max; ++j){
            mpz_pow_ui (b, a, j);
            solutions[pos] = mpz_get_str(NULL,10,b);
            pos++;
        }
    }

    //sort results
    qsort(solutions,pos-1,sizeof(char*),cstring_cmp);
    //count unique result strings
    for (int i = 0; i < pos-1; ++i){
        //printf("%s\n", solutions[i]); 
        if(strcmp(solutions[i], solutions[i+1])!=0) num++;
    }
    // the last has to be compared seperatly
    if(strcmp(solutions[pos-1], solutions[pos-2])!=0) num++;

    printf("%d %d\n", pos, num); 
    return 0; 
}
    